<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>CS 451</title><link rel="stylesheet" type="text/css" href="../../notion_styles.css"/></head><body><article id="81aa272c-eeb3-43c7-88eb-f48faa70ab05" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/chart-mixed_purple.svg"/></div><h1 class="page-title">CS 451</h1><p class="page-description"></p></header><div class="page-body"><h3 id="f30e5489-1e1d-4430-aa10-e5b2fd5be920" class=""><strong>Overview</strong></h3><ul id="bed38352-609d-4d56-b2ef-1013266da79f" class="bulleted-list"><li style="list-style-type:disc">We’re not going to design a fault-tolerant distributed computer network, we’re going to use one.</li></ul><ul id="af7044f2-3e81-4426-bbd5-7028bbc11d21" class="bulleted-list"><li style="list-style-type:disc">topic of first view lectures: <strong> abstract a distributed network?</strong></li></ul><figure id="8f710980-f676-4253-a286-111320d22eae" class="link-to-page"><a href="CS%20451/02%20%E2%80%94%20Map%20Reduce.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>02 — Map Reduce</a></figure><figure id="10d2e7d3-01e5-80a0-83a9-d952ef13ed17" class="link-to-page"><a href="CS%20451/03%20%E2%80%94%20From%20MapReduce%20to%20Spark.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>03 — From MapReduce to Spark</a></figure><figure id="1142e7d3-01e5-8027-8486-df681997ff7d" class="link-to-page"><a href="CS%20451/3%205%20%E2%80%94%20Scala%20Basics.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>3.5 — Scala Basics</a></figure><figure id="1142e7d3-01e5-8016-9958-d8a898651936" class="link-to-page"><a href="CS%20451/04%20%E2%80%94%20Analyzing%20Text.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>04 — Analyzing Text </a></figure><figure id="1342e7d3-01e5-80ce-a316-c19b47e5c087" class="link-to-page"><a href="CS%20451/05%20%E2%80%94%20Graphs.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>05 — Graphs</a></figure><figure id="1292e7d3-01e5-8007-842d-fd6f7cfd975a" class="link-to-page"><a href="CS%20451/06%20%E2%80%94%20ML%20Part%201%20(Data%20Mining)%201292e7d301e58007842dfd6f7cfd975a.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>06 —  ML Part 1 (Data Mining)</a></figure><figure id="13b2e7d3-01e5-80d3-8b70-f98a2f872822" class="link-to-page"><a href="CS%20451/06%20%E2%80%94%20ML%20Part%202%20(LSH,%20Min-Hashing,%20Clustering)%2013b2e7d301e580d38b70f98a2f872822.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>06 — ML Part 2 (LSH, Min-Hashing, Clustering)</a></figure><figure id="13e2e7d3-01e5-80af-aeec-dc875f7d4e64" class="link-to-page"><a href="CS%20451/07%20%E2%80%94%20Relational%20Data.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>07 — Relational Data</a></figure><figure id="1452e7d3-01e5-80e3-a7da-e9860fd949af" class="link-to-page"><a href="CS%20451/08%20%E2%80%94%20Streaming.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>08 — Streaming</a></figure><figure id="15e2e7d3-01e5-80b3-9326-c4118741b547" class="link-to-page"><a href="CS%20451/9%20%E2%80%94%20Mutable%20State.html"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/>9 — Mutable State</a></figure><figure id="15e2e7d3-01e5-802a-867c-ce758ff1550e" class="link-to-page"><a href="CS%20451/Analyzing%20Efficiency%20of%20Spark%20Programs.html"><img class="icon" src="https://www.notion.so/icons/dashboard_purple.svg"/>Analyzing Efficiency of Spark Programs</a></figure><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Assignment Learnings </summary><div class="indented"><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="2e767ef7-a6ea-41f8-abb9-68ee2cea08f1"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/question-mark_gray.svg"/></div><div style="width:100%"><p id="2386ba02-440a-4992-84b0-0088d360a257" class=""><code>Object2IntFrequencyDistribution</code> </p><p id="2c1b8b7e-3698-42fb-a49d-28f0429dcc50" class="">Data structure used to maintain a <em><span style="border-bottom:0.05em solid">frequency distribution of objects</span></em>, mapping each object to its corresponding integer count. </p><p id="33398c51-2655-4547-bd95-dff3c20575e7" class=""><strong>Features</strong></p><ol type="1" id="8d1f456d-86d2-40df-abf9-f6574de692d8" class="numbered-list" start="1"><li>It can handle<span style="border-bottom:0.05em solid"> any object type as the key</span></li></ol><ol type="1" id="bc96b5bc-9e1b-4099-bd98-1f2d8f07d910" class="numbered-list" start="2"><li>The values stored are integers, <span style="border-bottom:0.05em solid">representing the frequency</span> of each object.</li></ol><ol type="1" id="14d91b91-42d4-40c3-9eba-6e04e558d949" class="numbered-list" start="3"><li>Provides <span style="border-bottom:0.05em solid">methods to iterate</span> over the keys and their corresponding counts</li></ol></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="182b8ba5-9608-412d-9e6d-e2151de6e0be"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/question-mark_gray.svg"/></div><div style="width:100%"><p id="87260874-53c5-4e6f-98f6-395b87781414" class=""><strong>Benefit of having static objects for output key and value in mapper</strong></p><ul id="8c6f08bb-9873-4176-83bd-613e089db48e" class="bulleted-list"><li style="list-style-type:disc"><strong>Saves Overhead: </strong>You create the objects ONCE. As opposed to every-time the mapper runs. </li></ul><ul id="80ed6918-e8ae-42a6-8f34-5b6eb20027ce" class="bulleted-list"><li style="list-style-type:disc"><strong>State Management</strong>: Although the Mapper runs in a single thread, using static fields can help maintain state across method calls without worrying about concurrency issues in this context. If new instances are created directly, there&#x27;s no concern for shared mutable state, but you lose the benefit of reusing immutable objects.</li></ul></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="908090f9-3576-4153-9c31-538be21c2899"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/question-mark_gray.svg"/></div><div style="width:100%"><p id="de40682f-c099-4f44-b9dc-602a1fcd8a5b" class=""><strong>Why does the reducer have an iterable? </strong></p><p id="d7479acf-e1ab-48f9-af4b-901fa54b867d" class="">Reducer receives an <code>Iterable&lt;T&gt;</code> due to how MapReduce groups key-value pairs before they reach the reducer. </p><ul id="f4244ba4-c924-487d-9827-f70926b52a65" class="bulleted-list"><li style="list-style-type:disc">The framework standardizes grouping so that for each unique key (like <code>(term, docno)</code>), it aggregates all associated values into an <code>Iterable</code>. This is done even if there&#x27;s only one value in most cases.</li></ul><ul id="15e2e7d3-01e5-8064-affa-d496fbf13ff1" class="bulleted-list"><li style="list-style-type:disc">In case there are duplicate pairs, the reducer would sum up the values within <code>Iterable&lt;VIntWritable&gt;</code> to get the correct frequency, making it robust against data duplication.</li></ul></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-80a5-80b7-de7c2a1c2430"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="15e2e7d3-01e5-80f0-be63-df7c16281a85" class="">Spark</p><ul id="f9e83d7c-064b-43e9-b612-bebab6f5f1bf" class="bulleted-list"><li style="list-style-type:disc"><code>.sortByKey()</code> triggers a <strong>global sort</strong><ul id="15e2e7d3-01e5-8049-9f77-d845ca048761" class="bulleted-list"><li style="list-style-type:circle">⇒ expensive; involves a full shuffle operation</li></ul><ul id="2b2ff724-5782-4b79-bc8a-c57a98f9a761" class="bulleted-list"><li style="list-style-type:circle">⇒ No need for <code>.coalesce(1)</code> before sorting</li></ul></li></ul></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-8066-a5e2-ec4c6eca72f4"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="e566f5bf-afbb-4bb3-ae29-d0dbd9873f83" class=""><strong>An RDD of non-pairs does not have </strong><code><strong>reduceByKey</strong></code><strong>, only </strong><code><strong>reduce</strong></code><strong>.</strong></p><ul id="5984926e-a2cd-43bc-9070-f8aea2e1e79b" class="bulleted-list"><li style="list-style-type:disc">This is because <code>reduceByKey</code> only applies to a pairRDD (an RDD of tuples).</li></ul><ul id="15e2e7d3-01e5-8033-b39a-faec820655a6" class="bulleted-list"><li style="list-style-type:disc">e.g. turning a DF into an RDD results in: <code>RDD[Row]</code> which is not a pair-RDD.  </li></ul></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-8030-b379-cdc8773c22e5"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="270c77f4-66b4-4cc1-939c-15e4c16e2604" class=""><strong>Null values</strong></p><ul id="1f7940b3-2ab5-4292-9192-45ab32f88aa3" class="bulleted-list"><li style="list-style-type:disc"><code>.map</code> needs to return an item for each row.<p id="cc409067-9d4b-41b7-b8ad-ae403fb7e162" class="">⇒ if map does not emit anything, it show up as <code>null</code> for the next transformation </p></li></ul><ul id="feb6b9c5-2d28-4f6c-bf7e-87edf8770491" class="bulleted-list"><li style="list-style-type:disc"><code>flatMap</code> maps each input element to 0+ output elements <p id="73739e54-ecad-4e38-9ca6-92686e950080" class="">⇒ not explicitly returning <code>null</code> or placeholder values. </p></li></ul><ul id="cc8a7bce-0009-4a9b-92b6-6eb7bdfc9387" class="bulleted-list"><li style="list-style-type:disc"><code>count</code> counts null values <p id="04772613-24f0-418f-a995-50f3d7b56396" class="">⇒ <code>map(...).count()</code> will include <code>null values </code></p></li></ul><ul id="0e0b15ea-db23-4297-a423-dcbc07bb7efa" class="bulleted-list"><li style="list-style-type:disc">To not include null values when using <code>map</code>, use <code>filter</code> before-hand to filter-out null values. <ul id="ce3f8032-799b-44c8-a135-0cad26f9d08b" class="bulleted-list"><li style="list-style-type:circle">Note: If the input data contains null values, then you’ll try to call .equals() on a null value ⇒ error, so need to check for null values.</li></ul></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="42972b20-82ae-43e4-8226-ff7e03a19dc6" class="code"><code class="language-Scala">val count = lineitemRDD
	.filter((row: Row) =&gt; {
		// shipdate is the one and only column
		// assume format: &#x27;yyyy-mm-dd&#x27;
		val shipDate = row.getString(0)
		// don&#x27;t compare if null
		shipDate != null &amp;&amp; shipDate.equals(bc_dateStr.value)
	})
	.count()</code></pre></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-8005-8c30-e6fa6b3cd89d"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="647107df-ebed-492c-8f70-30e945e0bf15" class=""><code>rdd1.cogroup(rdd2)</code></p><hr id="a49004e3-385e-4eb0-ba43-7cbbe32a1fb0"/><p id="b164e753-a7f1-46c8-b773-3ef36bf712c5" class="">For every key k in <code>rdd1</code> &amp; <code>rdd2</code>: <div class="indented"><p id="55c1c543-46e5-4135-8cee-fc9871e14b8b" class="">([values with that key in <code>rdd1</code>], [values with that key in <code>rdd2</code>])</p></div></p><p id="967a8c55-eb65-48c3-9fc4-857f44e50f7b" class="">Note to make it into a join you have to filter out cases where one side is an empty []: </p><ul id="232dee7f-c21e-4d10-ba2d-084fa5fc7e65" class="bulleted-list"><li style="list-style-type:disc">For one to many: check if the <strong>many </strong>side is []</li></ul></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-80ea-aa48-f4b7689bcee4"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="7421d653-89cb-438f-8c76-cd4e5e063ac0" class=""><code>collect()</code><strong> </strong>(may) be needed before<strong> </strong><code>sortBy()</code></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f6462587-19ea-498e-9f74-dfbc69bbdc1b" class="code"><code class="language-Scala">.map({case ((key, name), count) =&gt; (key, name, count)})
.sortBy({case (key, _, _) =&gt; key})
.foreach(println)

// Output:
(4,EGYPT,8)
(9,INDONESIA,13)
(22,RUSSIA,13)
...</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ca8bf689-3205-4c4a-ac96-861357aba475" class="code"><code class="language-Scala">.map({case ((key, name), count) =&gt; (key, name, count)})
.collect()
.sortBy({case (key, _, _) =&gt; key})
.foreach(println)

// Output:
(0,ALGERIA,5)
(1,ARGENTINA,8)
(2,BRAZIL,15)
(3,CANADA,12)
...</code></pre></div></figure><figure class="block-color-default_background callout" style="white-space:pre-wrap;display:flex" id="1592e7d3-01e5-8015-b72c-dd117449e119"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/exclamation-mark_gray.svg"/></div><div style="width:100%"><p id="a911409a-b762-4549-889b-8bc051681485" class=""><code>.coalesce(numPartitions=1)</code></p><p id="e934b209-f17e-4a19-b4a9-cf00ed66be56" class="">To bring it down to 1 partition (e.g. before saving to a file) </p></div></figure></div></details><p id="15b2e7d3-01e5-805a-9885-f283c5074b91" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>