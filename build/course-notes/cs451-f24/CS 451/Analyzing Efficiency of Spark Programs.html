<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Analyzing Efficiency of Spark Programs</title><link rel="stylesheet" type="text/css" href="../../notion_styles.css"/></head><body><article id="15e2e7d3-01e5-802a-867c-ce758ff1550e" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/dashboard_purple.svg"/></div><h1 class="page-title">Analyzing Efficiency of Spark Programs</h1><p class="page-description"></p></header><div class="page-body"><h3 id="15e2e7d3-01e5-8016-910b-fff1a4fb7d34" class=""><strong>Understand Spark&#x27;s Execution Model</strong></h3><ul id="15e2e7d3-01e5-8083-a917-f920dbb1fcf8" class="bulleted-list"><li style="list-style-type:disc"><strong>RDDs and DAGs</strong>: Spark creates a Directed Acyclic Graph (DAG) of stages for execution based on the transformations and actions in your program. Each stage consists of a set of tasks that operate in parallel.</li></ul><ul id="15e2e7d3-01e5-8062-9221-c3497c5a28d1" class="bulleted-list"><li style="list-style-type:disc"><strong>Transformations</strong>: Spark transformations are categorized as <strong>narrow dependencies</strong> or <strong>wide dependencies</strong>:<ul id="15e2e7d3-01e5-8050-9b40-d5f3854345e8" class="bulleted-list"><li style="list-style-type:circle"><strong>Narrow Dependency</strong>: Each partition of the parent RDD contributes to only one partition of the child RDD. Examples: <code>map</code>, <code>filter</code>, <code>flatMap</code>.</li></ul><ul id="15e2e7d3-01e5-8071-8afb-fd55fcb39981" class="bulleted-list"><li style="list-style-type:circle"><strong>Wide Dependency</strong>: Data from one partition of the parent RDD can end up in multiple partitions of the child RDD, requiring a <strong>shuffle</strong>. Examples: <code>reduceByKey</code>, <code>groupByKey</code>, <code>join</code>.</li></ul></li></ul><ul id="15e2e7d3-01e5-80f6-b22c-c3ef71442df1" class="bulleted-list"><li style="list-style-type:disc"><strong>Shuffles</strong>: A shuffle involves redistributing data across the cluster. Shuffles are expensive due to I/O and network costs.<ul id="15e2e7d3-01e5-80fc-ac44-f30b705318cf" class="bulleted-list"><li style="list-style-type:circle"><strong>Partition Reorganization</strong>: Wide transformations require Spark to redistribute data to ensure all data for a key or range is in the same partition.</li></ul><ul id="15e2e7d3-01e5-8097-85c5-e42a98b29986" class="bulleted-list"><li style="list-style-type:circle"><strong>Cost of Shuffles</strong>:<ul id="dab42092-cbc4-45a8-8e80-d5b069247c09" class="bulleted-list"><li style="list-style-type:square"><strong>Disk I/O</strong>: Data is written to disk during the shuffle.</li></ul><ul id="94ee40d4-0a7b-464d-aec9-b3349fdc6b85" class="bulleted-list"><li style="list-style-type:square"><strong>Network I/O</strong>: Data is transferred between nodes.</li></ul><ul id="3246846c-e63b-4cb8-9123-6818b554a0a4" class="bulleted-list"><li style="list-style-type:square"><strong>Serialization/Deserialization</strong>: Data is serialized during transfer and deserialized upon receipt.</li></ul></li></ul></li></ul><h3 id="15e2e7d3-01e5-802b-93b3-ff1d532a8085" class=""><strong>Which Program Is Faster? </strong></h3><ol type="1" id="15e2e7d3-01e5-80bd-9234-fdc73384dcc6" class="numbered-list" start="1"><li><strong>Transformations</strong>:<p id="29a2c583-ab2a-40b5-bedf-bef4876429d6" class=""><em><mark class="highlight-gray">Examine the transformations in each program. Identify where </mark></em><em><mark class="highlight-gray"><strong>wide dependencies</strong></mark></em><em><mark class="highlight-gray"> occur. These will likely result in a shuffle. Narrow transformations (e.g., </mark></em><em><mark class="highlight-gray"><code>map</code></mark></em><em><mark class="highlight-gray">, </mark></em><em><mark class="highlight-gray"><code>filter</code></mark></em><em><mark class="highlight-gray">) do not require a shuffle and are typically faster.</mark></em></p><ul id="15e2e7d3-01e5-801c-934c-fc56cbf5de6f" class="bulleted-list"><li style="list-style-type:disc">Program A has more narrow transformations, avoiding shuffles.</li></ul><ul id="15e2e7d3-01e5-80c5-ab3b-dad19b72eb7f" class="bulleted-list"><li style="list-style-type:disc">Program B involves wide transformations like <code>groupByKey</code>, which triggers a shuffle.</li></ul></li></ol><ol type="1" id="15e2e7d3-01e5-80c1-8ce4-da566886cb06" class="numbered-list" start="2"><li><strong>Partitioning Awareness</strong>:<p id="15e2e7d3-01e5-80e0-a32b-cd5239737cd4" class=""><em><mark class="highlight-gray">If one program uses techniques like </mark></em><em><mark class="highlight-gray"><strong>partitionBy</strong></mark></em><em><mark class="highlight-gray"> or retains an existing partitioning, it may </mark></em><em><mark class="highlight-gray"><strong>avoid unnecessary shuffles</strong></mark></em><em><mark class="highlight-gray">. Operations like </mark></em><em><mark class="highlight-gray"><code>repartition</code></mark></em><em><mark class="highlight-gray"> or </mark></em><em><mark class="highlight-gray"><code>coalesce</code></mark></em><em><mark class="highlight-gray"> also influence shuffle behavior.</mark></em></p><ul id="15e2e7d3-01e5-8058-a360-e56d0c591f96" class="bulleted-list"><li style="list-style-type:disc">Program A may preserve partitioning using <code>partitionBy</code> or <code>reduceByKey</code>.</li></ul><ul id="15e2e7d3-01e5-800a-8cf0-e8419cbc9be4" class="bulleted-list"><li style="list-style-type:disc">Program B may ignore partitioning, leading to redundant shuffles.</li></ul></li></ol><ol type="1" id="15e2e7d3-01e5-80fc-adda-cb5067af4d20" class="numbered-list" start="3"><li><strong>Efficiency of Operations</strong>:<ul id="15e2e7d3-01e5-8008-8534-f2deb10be671" class="bulleted-list"><li style="list-style-type:disc">e.g., <code>reduceByKey</code> is more efficient than <code>groupByKey</code> because it combines values locally on each partition before shuffling.</li></ul></li></ol><ol type="1" id="15e2e7d3-01e5-807e-b370-c61027de6d66" class="numbered-list" start="4"><li><strong>Cost of Actions</strong>:<ul id="15e2e7d3-01e5-80d1-ba51-c3ab66433079" class="bulleted-list"><li style="list-style-type:disc">Look at the action triggering execution. </li></ul><ul id="15e2e7d3-01e5-80bb-8149-e0f2c1c23eba" class="bulleted-list"><li style="list-style-type:disc"><strong>To Prevent overloading the driver memory: </strong><ul id="15e2e7d3-01e5-808a-b286-f7ace27a39c8" class="bulleted-list"><li style="list-style-type:circle">Dont use <strong>actions </strong>w’ <strong>ounbounded output (e.g. </strong><code>countByKey</code>,but not <code>count</code>)</li></ul><ul id="15e2e7d3-01e5-8096-ad97-e93381f6e171" class="bulleted-list"><li style="list-style-type:circle">Use action like <code>saveAsTextFile</code> which goes to HDFS straight away. </li></ul></li></ul></li></ol><h3 id="15e2e7d3-01e5-8058-a9fb-c32437a0a336" class=""><strong>Tips to reduce #/size of Shuffles</strong></h3><ul id="15e2e7d3-01e5-80ad-bab3-decc886eb11d" class="bulleted-list"><li style="list-style-type:disc">Combine transformations like <code>filter</code> and <code>map</code> before a shuffle.</li></ul><ul id="15e2e7d3-01e5-80bb-bb93-c3fda66859dc" class="bulleted-list"><li style="list-style-type:disc">Use techniques like <strong>map-side pre-aggregation</strong> to reduce the amount of data shuffled</li></ul><ul id="15e2e7d3-01e5-8090-b6a5-dfdc7b7a6b19" class="bulleted-list"><li style="list-style-type:disc">Use alternative to <code>groupByKey</code> </li></ul><ul id="15e2e7d3-01e5-8095-9c34-ccc7e78b2a70" class="bulleted-list"><li style="list-style-type:disc"><strong>Leverage Partitioning</strong>:<ul id="15e2e7d3-01e5-8027-acb0-fcef561ba8a8" class="bulleted-list"><li style="list-style-type:circle">Use <code>partitionBy</code> when working with key-value pairs to avoid redundant shuffles.</li></ul><ul id="15e2e7d3-01e5-80f6-ac2d-e53ca8ca862e" class="bulleted-list"><li style="list-style-type:circle">Ensure partitioning is preserved across operations (don’t need to reshuffle)</li></ul></li></ul><ul id="15e2e7d3-01e5-806b-821e-da3fe6429ec8" class="bulleted-list"><li style="list-style-type:disc"><strong>Understand Narrow vs Wide Transformations</strong>:<ul id="15e2e7d3-01e5-8050-8d58-c9f1e53c78fd" class="bulleted-list"><li style="list-style-type:circle">Narrow transformations like <code>map</code> and <code>filter</code> execute faster and avoid shuffles.</li></ul><ul id="15e2e7d3-01e5-80b0-ad5f-e442bef19593" class="bulleted-list"><li style="list-style-type:circle">Wide transformations like <code>join</code> and <code>groupByKey</code> introduce shuffles and are slower.</li></ul></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>