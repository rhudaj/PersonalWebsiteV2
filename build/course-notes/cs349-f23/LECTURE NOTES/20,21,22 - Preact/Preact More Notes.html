<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Preact: More Notes</title><link rel="stylesheet" type="text/css" href="/course-notes/notion_styles.css"/></head><body><article id="3e0b5f88-0a1d-4cc8-9fbf-dfa5fbb536aa" class="page sans"><header><h1 class="page-title">Preact: More Notes</h1><p class="page-description"></p></header><div class="page-body"><figure class="block-color-default callout" style="white-space:pre-wrap;display:flex" id="cdc0b2d7-6be9-4812-ade3-194dd22ac0ae"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/code_gray.svg"/></div><div style="width:100%"><em><strong>id</strong></em><strong><strong><strong><strong><strong><strong> vs. </strong></strong></strong></strong></strong></strong><em><strong>class</strong></em><strong><strong><strong><strong><strong><strong> vs. </strong></strong></strong></strong></strong></strong><em><strong>key</strong></em><p id="2cac877f-cadc-4d7d-ad9d-da40b7d8a2f2" class=""><strong><strong>Why care? </strong></strong><div class="indented"><p id="e2fcc6fe-ea43-49d4-8253-d79fcfd3ccb4" class="">Preact sometimes &quot;guesses&quot; how the shape of the tree has changed between two renders; usually when <em><strong>comparing lists. </strong></em></p></div></p><p id="2f9596fb-86b1-4973-8a80-ce0ae02f7af0" class=""><strong><strong><strong>key</strong></strong></strong><div class="indented"><p id="276602be-ed13-406a-a0a4-6e9f1e81820a" class="">If items are changing <em>order → </em>add a <code>key</code> prop to each item</p><p id="5b60c1d7-f509-406c-a4a3-d36788bd9e01" class="">Instead of comparing the <em>order</em> of elements between two trees, elements with a <code>key</code> prop are compared</p><p id="a0f6ff64-3a68-49a4-b73e-6c169f6c322d" class="">A <code>key</code> can be any type of value, as long as repeated renders of the same item  have the exact same <code>key</code> </p></div></p></div></figure><figure class="block-color-default callout" style="white-space:pre-wrap;display:flex" id="3cdc1fc1-22c6-4bf2-92f3-1c148aa904f4"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/code_gray.svg"/></div><div style="width:100%"><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Memoization</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><p id="4ba69e69-e2b5-4bc4-b5c2-a1f610f47eb0" class=""><strong><strong><strong><strong><strong>What? </strong></strong></strong></strong></strong><div class="indented"><p id="1e53377d-a367-48ac-b012-ad3eacbbb3aa" class="">cache the results of a calculation allowing it to be reused when the same input is used.</p></div></p><p id="c0f18e44-1ff0-4db7-b863-5bceadc5999d" class=""><strong><strong><strong><strong><strong>How? </strong></strong></strong></strong></strong><div class="indented"><p id="5ef99409-9429-42ae-8211-a6219db20f69" class="">With the <code>useMemo</code> hook we can memoize the results of that computation and only recalculate it when one of the dependencies changes.</p><pre id="c0105bbe-7df1-40f8-abc9-dc3d36adf2e5" class="code"><code>const memoized = useMemo(
  () =&gt; expensive(a, b),
  // Only re-run the expensive function when any of these
  // dependencies change
  [a, b]
);</code></pre></div></p></div></figure><figure class="block-color-default callout" style="white-space:pre-wrap;display:flex" id="1e40b34a-358e-4514-b645-9597637cfc63"><div style="font-size:1.5em"><img class="icon" src="https://www.notion.so/icons/code_gray.svg"/></div><div style="width:100%"><strong><strong><strong><strong><strong><strong><strong><strong>Signals</strong></strong></strong></strong></strong></strong></strong></strong><p id="aaec82cd-28f7-41d7-b0c7-86a483323fae" class="">Signals track when their value is <strong>accessed</strong> and <strong>updated</strong></p><ol type="1" id="58974fcb-284a-4dcc-b1f1-5efd94398e44" class="numbered-list" start="1"><li><strong>Accessing a signal’s </strong><code><strong>.value</strong></code><strong>  from within a component </strong>automatically re-renders the component when that signal’s value changes<p id="35b0ee9f-b6db-4a31-8e5c-bcce5e621766" class=""><mark class="highlight-gray">→ As a result, a signal can be updated without re-rendering the components it was passed through because those components see the signal and not its value</mark></p></li></ol></div></figure><figure class="block-color-default callout" style="white-space:pre-wrap;display:flex" id="e9b5aea7-339f-4523-ba34-7bda5a7866a1"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"><strong>useState → setState</strong><p id="7d57b4c3-7449-40d3-8683-9decc115afa8" class="">calling <code>setState</code> outside of a useEffect will cause the component (<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>AND ONLY THAT COMPONENT</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>) to re-render</p></div></figure><figure class="block-color-default callout" style="white-space:pre-wrap;display:flex" id="4138b8e9-799a-44ca-b4f2-d78af9248e4b"><div style="font-size:1.5em"><span class="icon">❗</span></div><div style="width:100%"><strong><strong><strong><strong><strong><strong><strong><strong><strong>useEffect</strong></strong></strong></strong></strong></strong></strong></strong></strong><ul id="75f1e7e9-0e19-4730-9baf-251aeca3f913" class="bulleted-list"><li style="list-style-type:disc">return() inside the handler:  <ul id="2ef91a03-0712-4bdd-8bb6-799985357a94" class="bulleted-list"><li style="list-style-type:circle">has the old (x,y) values </li></ul><ul id="70a5eb14-06ff-4d59-afab-e443e4190fec" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-orange_background">not called when object first mounts !</mark></li></ul></li></ul><ul id="f7349654-fea1-4cf4-9b3f-63eb1ac95606" class="bulleted-list"><li style="list-style-type:disc">handler: <ul id="b61e6532-578b-4567-b312-3085a3025fe2" class="bulleted-list"><li style="list-style-type:circle">has the new (x,y) values</li></ul></li></ul><pre id="f44baa2e-1617-467d-b17f-0e1534eb2395" class="code"><code>useEffect(() =&gt; {
    console.log(`useEffect1: (${x}, ${y})`); //new x,y
    return () =&gt; {
			//Not called when first mounted
      console.log(`useEffect2: (${x}, ${y})`); //old x,y
    }
  }, [x,y])</code></pre></div></figure><p id="aac043bf-9b4f-4155-aee1-13939ac51f88" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>