<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3.5 — Scala Basics</title><link rel="stylesheet" type="text/css" href="../../notion_styles.css"/></head><body><article id="1142e7d3-01e5-8027-8486-df681997ff7d" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="https://www.notion.so/icons/folder_purple.svg"/></div><h1 class="page-title">3.5 — Scala Basics</h1><p class="page-description"></p></header><div class="page-body"><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0"><strong>Overview</strong></summary><div class="indented"><ul id="1142e7d3-01e5-806c-a0a6-d29f7e510b7f" class="bulleted-list"><li style="list-style-type:disc">Built on top of JVM<ul id="1142e7d3-01e5-802a-b107-c307cf8793ff" class="bulleted-list"><li style="list-style-type:circle">⇒ you can write MapReduce code in Scala.</li></ul></li></ul><ul id="15a2e7d3-01e5-8006-9ac0-ff7dd44d4594" class="bulleted-list"><li style="list-style-type:disc">Similarties to JavaScript: <ul id="1142e7d3-01e5-8061-84b2-d692fa15b677" class="bulleted-list"><li style="list-style-type:circle">Funtional &amp; Object oriented</li></ul><ul id="1142e7d3-01e5-8032-842d-e224dba73156" class="bulleted-list"><li style="list-style-type:circle">Every value is an object</li></ul><ul id="1142e7d3-01e5-80bf-a1bc-ffca67eaf34e" class="bulleted-list"><li style="list-style-type:circle">Every function is a value</li></ul></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">vs. Java</summary><div class="indented"><p id="1142e7d3-01e5-80ff-889a-dc8d612ba1e3" class="">When defining classes in Scala:</p><ul id="1142e7d3-01e5-80a3-b76b-eb1ae6d56542" class="bulleted-list"><li style="list-style-type:disc">You use the <code>class</code> keyword, followed by the class name.</li></ul><ul id="1142e7d3-01e5-80da-95df-c9fdd9c3791c" class="bulleted-list"><li style="list-style-type:disc">Scala&#x27;s generics use brackets (<code>[]</code>), similar to templates in C++.</li></ul><ul id="1142e7d3-01e5-8035-863d-c4cbe548a0c0" class="bulleted-list"><li style="list-style-type:disc">The <code>override</code> keyword replaces <code>@Override</code> used in Java.</li></ul><ul id="15a2e7d3-01e5-80da-88c3-efeae4923980" class="bulleted-list"><li style="list-style-type:disc"><strong>type inference:</strong> Unlike Java, Scala does not automatically infer the correct <code>context</code> subclass, requiring you to explicitly specify it. Additionally, the <code>#</code> sign refers to an inner class.</li></ul><ul id="15a2e7d3-01e5-808b-bec7-fb606c1098c7" class="bulleted-list"><li style="list-style-type:disc"><strong>operator overloading:</strong> every operator is a method in a class, but sometimes certain operations are handled through type expansion or conversion.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Implicit Returns</summary><div class="indented"><p id="11a2e7d3-01e5-807d-9fe2-ec114daf0baa" class=""><strong>“return” </strong>can be used. But, the last expression evaluated in a function is automatically returned.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="11a2e7d3-01e5-802a-b69a-ea3e9ef984d6" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">def add(a: Int, b: Int):3 Int = {
  a + b  // No explicit return, this value is returned implicitly
}</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Printing </summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-80f3-b6c4-efedf07e8bde" class="code"><code class="language-Scala">println(“Hello, World”) // print a String
println(2 + 2)          // print an Int
println(1,2,3)          // 3x Int print Combo!
//  If you give println multiple values, it puts them in parentheses automatically
printf(“Welcome to Scala, CS%d”, 451</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Strings</summary><div class="indented"><p id="1142e7d3-01e5-80f6-9faa-eed70e138900" class="">Same format as C, C++ </p><ul id="1142e7d3-01e5-8000-8a93-de022575012d" class="bulleted-list"><li style="list-style-type:disc"><strong>format string:</strong> by starting the string with a <strong>dollar sign ($)</strong>. This allows you to embed expressions directly into the string.</li></ul><ul id="1142e7d3-01e5-804d-b6f7-eb7a8095b14f" class="bulleted-list"><li style="list-style-type:disc">If your embedded expression contains <strong>whitespace</strong>, you need to <strong>enclose the expression in curly braces </strong><code><strong>{}</strong></code>. For example:<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-80ac-a9e4-c8336e246abe" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">val result = s&quot;This is a string with 2 + 2 = ${2 + 2}&quot;</code></pre></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Variables</summary><div class="indented"><p id="1142e7d3-01e5-8065-9cb2-d94f16369ea4" class=""><strong>2 Types: </strong></p><ol type="1" id="1142e7d3-01e5-801e-a6a2-dcb8cdebbc61" class="numbered-list" start="1"><li><code>var</code>: mutable</li></ol><ol type="1" id="1142e7d3-01e5-802c-848f-ce674c511142" class="numbered-list" start="2"><li><code>val</code>: immutable</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-80e6-9f55-df439239ee3b" class="code"><code class="language-Scala">var vi : Int = 3 // mutable integer
val ci : Int = 5 // constant integer</code></pre><p id="1142e7d3-01e5-8054-8969-c1d1aec0162a" class=""><strong>Note on </strong><code><strong>val</strong></code></p><ul id="1142e7d3-01e5-80ca-9a3c-f2a1b8c12f42" class="bulleted-list"><li style="list-style-type:disc">means identifer (a fixed pointer in background) cant change. </li></ul><ul id="1142e7d3-01e5-805f-a649-f39c7e187e70" class="bulleted-list"><li style="list-style-type:disc">Does not mean the object itself can&#x27;t change the value it represents<ul id="1142e7d3-01e5-8032-91c2-fd36915f7a20" class="bulleted-list"><li style="list-style-type:circle">ie: if it points to array, you can change the array </li></ul></li></ul><h3 id="1142e7d3-01e5-80b3-90bc-f478f268a44c" class="">Variable Assigment</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-8069-bad1-c5bd56c3de9a" class="code"><code class="language-Scala">var x = 3 // type inference!  x is an Int
x = 4     // assignment!
x += 2    // assignment!
x = “foo” // invalid! x is Int, not String</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Collections (Array, List)</summary><div class="indented"><p id="1142e7d3-01e5-8007-9d0f-e3e7c1eba210" class=""><strong>Creating an Array:</strong><div class="indented"><p id="1142e7d3-01e5-8067-bc8c-c450186e5f6d" class="">Using the <code>Array</code> constructor</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-8073-92f7-f592c409e12d" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">var myArray = Array(1, 2.0, 3)</code></pre><p id="1142e7d3-01e5-80c4-aa13-e1aec9678b15" class=""><strong>Generic type system: </strong>This array holds multiple types of numeric values (integers and doubles); <em>generic type system </em>automatically inferring the array type based on the provided values.</p></div></p><p id="1142e7d3-01e5-809d-9174-ed60f2d31634" class=""><code><strong>Any</strong></code><strong> &amp; Type Inference</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-8033-8c70-e450da9c15c3" class="code"><code class="language-Scala">var myArray = Array[Any](1, 2.0, 3)
// or:
var myArray : Array[Any] = Array(1, 2.0, 3)</code></pre><ul id="1142e7d3-01e5-8066-9f34-eaa391b79802" class="bulleted-list"><li style="list-style-type:disc"><strong>With Mixed Types: </strong>To create an array that can hold any type, you can specify <code>Array[Any]</code>, allowing elements to be of different types, such as <code>Int</code>, <code>Double</code>, or even <code>String</code>.</li></ul><ul id="1142e7d3-01e5-8041-934c-f38efe17ef6a" class="bulleted-list"><li style="list-style-type:disc"><strong>Explicit Type: </strong>If you explicitly declare the type, such as <code>Array[Int]</code>, then adding a double would lead to a compilation error. </li></ul><p id="1142e7d3-01e5-8058-b302-fa8efdf09929" class=""><strong>Accessing Elements:</strong><div class="indented"><p id="1142e7d3-01e5-8097-91f9-dc609a95b690" class="">Using their index:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-8057-9862-e54cfbc1aa72" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">myArray(0)  // Accesses the first element</code></pre></div></p><p id="1142e7d3-01e5-8051-8c16-c4512dd7b461" class=""><strong>Array Methods:</strong></p><ul id="1142e7d3-01e5-80e2-a847-cd3118291a8f" class="bulleted-list"><li style="list-style-type:disc"><code>reverse</code>: Reverses the array.</li></ul><ul id="1142e7d3-01e5-805c-94b3-de572b4be5bc" class="bulleted-list"><li style="list-style-type:disc"><code>zip</code>: Combines two arrays of the same length into an array of pairs.</li></ul><ul id="1142e7d3-01e5-8063-8627-cb841a17f60e" class="bulleted-list"><li style="list-style-type:disc"><code>zipWithIndex</code>: Pairs each element with its index.</li></ul><ul id="1142e7d3-01e5-805b-8a21-fbec715eace4" class="bulleted-list"><li style="list-style-type:disc"><code>sorted</code>: Returns a sorted copy of the array.</li></ul><ul id="1142e7d3-01e5-8063-a19b-f57e230bdeca" class="bulleted-list"><li style="list-style-type:disc"><code>sort</code>: Sorts the array in place but requires the array to be mutable.</li></ul><p id="1142e7d3-01e5-806e-b74e-d5a6b249fdd2" class=""><strong>Array Operators</strong><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-8021-af40-cc16790f4873" class="code"><code class="language-Scala">scala&gt; Array(1,2) ++ Array(3)
Array[Int] = Array(1,2,3)
scala&gt; Array(1,2) :+ 3
Array[Int] = Array(1,2,3)

 val a = Array(1,2)
 a :+= 3
// Error: :+= is not a member of Array[Int].
// Cannot convert to assignment as a is not assignable</code></pre><ul id="1142e7d3-01e5-8078-b0a9-e7342e5e74c9" class="bulleted-list"><li style="list-style-type:disc"><strong>Concatenation</strong>: The <code>+</code> operator can concatenate two arrays, but it creates a new array instead of modifying the existing ones, as arrays are of fixed length.</li></ul><ul id="1142e7d3-01e5-808d-9a0d-f203fccee039" class="bulleted-list"><li style="list-style-type:disc"><strong>Appending</strong>:<ul id="81f66678-53a0-4f0e-b1d8-5115dbc327ea" class="bulleted-list"><li style="list-style-type:circle">The use of <code>++</code> (or similar syntax) adds elements to an array but creates a new one instead of modifying the original.</li></ul><ul id="8eab151f-3c33-4505-9d0f-c3880304c711" class="bulleted-list"><li style="list-style-type:circle">The concept of <strong>mutability</strong> is emphasized: an array doesn’t change its size once defined.</li></ul></li></ul></div></p><p id="1142e7d3-01e5-800b-938e-db1e5355fa75" class=""><strong>Lists vs. Arrays</strong>:</p><ul id="a9bd3f0a-41d1-4383-b8e0-6d90cfae0467" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Lists</span> allow easy addition of elements at the front, maintaining immutability for the rest of the structure. </li></ul><ul id="1142e7d3-01e5-808d-8d6d-ce3c092554f8" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid">Arrays</span> are fixed in size and cannot be easily modified without creating new instances.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"><mark class="highlight-default">Maps</mark></summary><div class="indented"><ul id="1142e7d3-01e5-80c0-adea-d85d00214f99" class="bulleted-list"><li style="list-style-type:disc">A map is defined using a <strong>map constructor function</strong> (denoted as <code>Map</code>). It consists of pairs of key-value mappings.</li></ul><ul id="1142e7d3-01e5-800d-82bf-e9d0a40a15f0" class="bulleted-list"><li style="list-style-type:disc"><strong>2 types: Mutable, Immutable</strong><ul id="1142e7d3-01e5-8095-88e9-e49e1dbda988" class="bulleted-list"><li style="list-style-type:circle">The default maps are <span style="border-bottom:0.05em solid">immutable</span>, meaning that once a map is created, it cannot be modified. Instead of modifying the existing map, any operation that would typically alter it will return a new map based on the original.</li></ul></li></ul><ul id="1142e7d3-01e5-8087-bcd1-e049a0850b05" class="bulleted-list"><li style="list-style-type:disc">2 Ways to define: <ul id="15a2e7d3-01e5-80d8-bf0b-f5743a1985bf" class="bulleted-list"><li style="list-style-type:circle"><strong>Tuple Notation</strong>: <code>(a, b)</code> </li></ul><ul id="15a2e7d3-01e5-8028-aac9-edc25e3bb4ab" class="bulleted-list"><li style="list-style-type:circle"><strong>Arrow Notation</strong>: <code>a -&gt; b</code> </li></ul></li></ul><ul id="1142e7d3-01e5-8076-b904-cab627d19458" class="bulleted-list"><li style="list-style-type:disc">Pairs can be extended to any # of elements (e.g. triples, quadruples, etc.) </li></ul><p id="1142e7d3-01e5-805a-b666-d5c6f343f318" class=""><strong>Mutable, Immutable</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1142e7d3-01e5-806f-9377-ddf2a3a10e1a" class="code"><code class="language-Scala">// Immutable

	var m = Map(“a”-&gt;3)
	m += (“b” -&gt; 4)

  // +=: If the key already exists, it discards the previous association and assigns it to a new value, creating a new map instance and reassigning M
	// map + pair makes a new map
	// += is assigning this new map to m

// Mutable

	val m = mutable.Map(“a” -&gt; 3)
	// mutable.Map has its own += operator that mutates the existing value
	m += (“b” -&gt; 4)  // does not reassign m</code></pre><h3 id="1142e7d3-01e5-80cd-9f41-e7ccf41c17a1" class="">Functional vs. Mutable Data Structures</h3><ul id="1142e7d3-01e5-80f4-a7f1-dfb81fda6367" class="bulleted-list"><li style="list-style-type:disc"><strong>Functional Data Structures</strong>: safer, slower<ul id="1142e7d3-01e5-8066-ae71-e267b264aff2" class="bulleted-list"><li style="list-style-type:circle">The default behavior of data structures in this context is functional, meaning they are designed to be immutable. Modifications do not alter the original structure but create new instances based on the existing one.</li></ul><ul id="1142e7d3-01e5-8099-81aa-fb49421e27a1" class="bulleted-list"><li style="list-style-type:circle">This approach aligns with functional programming principles, promoting safer code practices by minimizing side effects.</li></ul><ul id="1142e7d3-01e5-80ad-8d9b-f51778f01a3e" class="bulleted-list"><li style="list-style-type:circle"><strong>slower: </strong>For example, inserting elements into an immutable hash table can involve overhead for copying and managing multiple instances.</li></ul></li></ul><ul id="1142e7d3-01e5-8049-bec6-cf4208ce936d" class="bulleted-list"><li style="list-style-type:disc"><strong>Mutable Data Structures</strong>:<ul id="1142e7d3-01e5-80c6-8998-d109d1095f51" class="bulleted-list"><li style="list-style-type:circle">While the default is immutable, mutable variants of <code>maps</code> (and other data structures) are available. These allow for in-place modifications, which can be more efficient for certain operations but may introduce side effects.</li></ul><ul id="1142e7d3-01e5-80de-ae48-f38a0f40fbff" class="bulleted-list"><li style="list-style-type:circle">Mutable structures are part of the collections library, catering to scenarios where mutability is necessary or more efficient.</li></ul><ul id="1142e7d3-01e5-808c-a344-e6d23bffd139" class="bulleted-list"><li style="list-style-type:circle">They ensure that changes to one map do not unintentionally affect others.</li></ul></li></ul><h3 id="1142e7d3-01e5-8046-8cf8-c5c811e9a045" class="">Performance Considerations</h3><ul id="1142e7d3-01e5-8089-b02b-d64aac3c2460" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance of Functional Operations</strong>:<ul id="1142e7d3-01e5-809b-a236-c459ce30fcda" class="bulleted-list"><li style="list-style-type:circle">Some functional methods can be slow, particularly for operations that involve copying or creating new instances rather than modifying in place. For example:<ul id="1142e7d3-01e5-8031-859f-dcfeec0dfcb2" class="bulleted-list"><li style="list-style-type:square"><strong>Lists</strong>: Appending elements to the front of a list is efficient. However, appending to the back could be costly due to the need to create a new list.</li></ul><ul id="1142e7d3-01e5-8061-81de-ea5dd1770929" class="bulleted-list"><li style="list-style-type:square"><strong>Arrays</strong>: Functional arrays should generally be avoided for dynamic operations since they can lead to inefficiencies due to their fixed size.</li></ul></li></ul></li></ul><h3 id="1142e7d3-01e5-80f1-a5c3-c501a5b2f0c6" class=""><strong>Working with Word Counts and Co-occurrences</strong></h3><ul id="1142e7d3-01e5-80c4-9651-ff28141a111c" class="bulleted-list"><li style="list-style-type:disc"><strong>Stripes</strong>:<ul id="1142e7d3-01e5-801d-9d9b-f4d121565953" class="bulleted-list"><li style="list-style-type:circle">In the context of word-count (like processing Shakespeare&#x27;s text), stripes represent structures mapping words to their co-occurrences.</li></ul><ul id="1142e7d3-01e5-8019-81ef-f8ae8e5e2a1e" class="bulleted-list"><li style="list-style-type:circle">The merging of stripes should be efficient, avoiding unnecessary duplication. If mutable maps are used incorrectly, it can lead to performance degradation due to repeated copying.</li></ul></li></ul><ul id="1142e7d3-01e5-8036-b286-e508b4f4385d" class="bulleted-list"><li style="list-style-type:disc"><strong>Using </strong><code>+=</code><strong> for Merging</strong>:<ul id="1142e7d3-01e5-80e9-aacb-c1178598d9b5" class="bulleted-list"><li style="list-style-type:circle">The <code>+=</code> operator for maps implies merging two maps where conflicts resolve by retaining the right-hand side&#x27;s value.</li></ul><ul id="1142e7d3-01e5-80e3-aa3f-ccc888a9a617" class="bulleted-list"><li style="list-style-type:circle">The implementation of merging should be optimized to avoid creating temporary copies unnecessarily. If the stripes are mutable, it can lead to performance issues, especially with large data sets.</li></ul></li></ul><h3 id="1142e7d3-01e5-8042-9f9c-c50cf1e02f6c" class="">Performance and Accumulation</h3><ul id="1142e7d3-01e5-80cc-a3c9-def74c5c8c90" class="bulleted-list"><li style="list-style-type:disc"><strong>Accumulators vs. Collectors</strong>:<ul id="1142e7d3-01e5-80da-8e83-ecdcdef34456" class="bulleted-list"><li style="list-style-type:circle">The concept of <span style="border-bottom:0.05em solid">accumulating</span> results in <span style="border-bottom:0.05em solid">functional programming</span> is crucial. When <span style="border-bottom:0.05em solid">merging maps</span>, it’s essential to minimize the duplication of data structures.</li></ul><ul id="1142e7d3-01e5-8079-badb-fcae00fbc794" class="bulleted-list"><li style="list-style-type:circle">Stripes should be designed to grow efficiently without causing excessive overhead. Efficient management of the collector variable can help achieve better performance.</li></ul></li></ul><ul id="1142e7d3-01e5-808e-9a81-e346172c6ded" class="bulleted-list"><li style="list-style-type:disc"><strong>Final Notes</strong>:<ul id="1142e7d3-01e5-8084-8cc4-c35d0750204c" class="bulleted-list"><li style="list-style-type:circle">The code&#x27;s efficiency significantly depends on the choices made regarding mutable and immutable structures.</li></ul><ul id="1142e7d3-01e5-80f7-8ff6-cc2ec218005e" class="bulleted-list"><li style="list-style-type:circle">The suggestion to switch to immutable structures, when properly managed, can lead to simpler and more efficient code, particularly in functional programming paradigms.</li></ul></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Functions </summary><div class="indented"><p id="1142e7d3-01e5-80a8-acf9-f11562cb3009" class=""><strong>Standard:</strong><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1059f79e-02e9-4f4b-a8ab-735ec36ecbbd" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">def square(x: Int): Int = x * x</code></pre><p id="1dd66d52-960d-459a-bee6-041b597d6f3c" class="">Infers the return type from the expression, though you can specify it explicitly.</p></div></p><p id="1142e7d3-01e5-804a-8a4e-ffef7b262f5d" class=""><strong>Anonymous Functions:</strong></p><ul id="1142e7d3-01e5-80ee-bd22-c28d3c5c6244" class="bulleted-list"><li style="list-style-type:disc">Functions that do not have a name and can be defined in the moment where they&#x27;re required.</li></ul><ul id="550a261c-b164-45ed-a874-90c700ea16d8" class="bulleted-list"><li style="list-style-type:disc">also called <span style="border-bottom:0.05em solid">lambda functions</span><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5f97d026-2bca-447c-a833-43c23f5d1457" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">val square = (x: Int) =&gt; x * x</code></pre><ul id="1142e7d3-01e5-808c-ac11-d6f4eb20f67c" class="bulleted-list"><li style="list-style-type:circle">can make your code more concise but require understanding how Scala infers types. explicit type declarations are required in some cases, especially for function parameters.</li></ul></li></ul><p id="1142e7d3-01e5-80a0-9651-d8c171cbdba8" class=""><strong>Higher-Order Functions</strong></p><ul id="1142e7d3-01e5-806a-b321-e9770d019d67" class="bulleted-list"><li style="list-style-type:disc">Functions that take other functions as arguments or return them as results. Examples include:<ul id="ba9f2a5e-247b-471b-9b46-96e9427100ed" class="bulleted-list"><li style="list-style-type:circle">e.g. <code>filter</code>, <code>reduce</code> / <code>reduceRight</code></li></ul><ul id="1142e7d3-01e5-8078-81f4-d16a476d7651" class="bulleted-list"><li style="list-style-type:circle">When passing an anonymous function to a higher-order function (like <code>map</code>), you don&#x27;t always need to specify the types, as Scala can infer them.</li></ul></li></ul><p id="1142e7d3-01e5-8069-81f6-fc668d8f78b1" class=""><strong>Using </strong><code><strong>_</strong></code><strong> for Anonymous Parameters:</strong><div class="indented"><ul id="38f17c02-5b2f-4e05-b456-0ce519a129cb" class="bulleted-list"><li style="list-style-type:disc">If you want to write a concise anonymous function that uses the parameter only once, you can use the underscore <code>_</code>:<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="65e2a0b2-24a1-4bdd-8465-bde2371cf082" class="code"><code class="language-Scala" style="white-space:pre-wrap;word-break:break-all">scala
Copy code
myArray.map(_ + 1)  // Adds 1 to each element</code></pre></li></ul></div></p><p id="1142e7d3-01e5-807d-8741-e8486538f31c" class="">
</p></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Loops / Collections </summary><div class="indented"><h3 id="1142e7d3-01e5-803c-9a90-dc2f5cf38a73" class="">Collection Methods</h3><ul id="1142e7d3-01e5-807a-804d-ff3f86ba61da" class="bulleted-list"><li style="list-style-type:disc"><strong>Aggregation</strong>: You can sum elements in a collection using methods like:<ul id="1142e7d3-01e5-80a4-9326-c1000196e173" class="bulleted-list"><li style="list-style-type:circle"><code><strong>sum</strong></code>: Directly sums up elements if the collection supports it.</li></ul><ul id="1142e7d3-01e5-80bf-8126-fd2cf4d263f0" class="bulleted-list"><li style="list-style-type:circle"><code><strong>reduce</strong></code>: Manually implements summation, highlighting its versatility across different collection types.</li></ul></li></ul><h3 id="1142e7d3-01e5-803e-b413-cc7a15ea4780" class="">Iterating Through Collections</h3><ul id="1142e7d3-01e5-8034-8454-ec869589f4d2" class="bulleted-list"><li style="list-style-type:disc"><strong>forEach</strong>: Iterates through elements and applies a provided function.</li></ul><ul id="1142e7d3-01e5-80e8-baac-d5d97f315eb7" class="bulleted-list"><li style="list-style-type:disc"><strong>Traditional for Loop</strong>:<ul id="f3e30254-417b-4866-a99a-31c28b5044d3" class="bulleted-list"><li style="list-style-type:circle">The syntax is simplified, e.g., <code>for variable in array</code>.</li></ul><ul id="fe4d2484-9755-4c51-b86d-c250fd92391c" class="bulleted-list"><li style="list-style-type:circle">Can utilize a <strong>range iterator</strong> (e.g., <code>1 to 10</code>) to generate sequences without needing to create an explicit array.</li></ul></li></ul><h3 id="1142e7d3-01e5-8068-930f-d8c5ebc2159a" class="">Range Objects</h3><ul id="1142e7d3-01e5-8051-8abf-e6418eb75827" class="bulleted-list"><li style="list-style-type:disc"><strong>Inclusive Range</strong>: A special syntax (like <code>1 to 10</code>) creates a range that includes both endpoints.</li></ul><ul id="1142e7d3-01e5-8022-9e05-f6d916c0f2da" class="bulleted-list"><li style="list-style-type:disc"><strong>Iterator Behavior</strong>: The range object yields values one at a time, instead of storing them all at once, which is efficient for memory usage.</li></ul><ul id="1142e7d3-01e5-80fd-b74e-c0bdba47a84a" class="bulleted-list"><li style="list-style-type:disc"><strong>Exclusive Range</strong>: There’s a syntax (not explicitly mentioned) to create ranges that exclude the end value.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0"> Function and Collection Handling</summary><div class="indented"><ol type="1" id="1142e7d3-01e5-80f9-826b-c71307aec595" class="numbered-list" start="1"><li><strong>Return Behavior in Functions</strong>:<ul id="1142e7d3-01e5-8073-b442-d862c41cf580" class="bulleted-list"><li style="list-style-type:disc">Prefer omitting the <code>return</code> keyword in functions.</li></ul><ul id="1142e7d3-01e5-807c-9792-e9c7b4b7e111" class="bulleted-list"><li style="list-style-type:disc">The last expression in the function body automatically becomes the return value, eliminating ambiguity about the return type.</li></ul><ul id="1142e7d3-01e5-80c9-8522-d7178ef366e7" class="bulleted-list"><li style="list-style-type:disc">If multiple return points are necessary, explicitly define the return type.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-8053-8820-f809be147932" class="numbered-list" start="2"><li><strong>Using Maps</strong>:<ul id="1142e7d3-01e5-800f-9138-f2a6e2266082" class="bulleted-list"><li style="list-style-type:disc">Maps support similar methods to collections, including the <code>map</code> method.</li></ul><ul id="1142e7d3-01e5-8032-850f-ca84fe064ae1" class="bulleted-list"><li style="list-style-type:disc">Accessing key-value pairs can be done with a <code>for</code> loop or <code>forEach</code> method.</li></ul><ul id="1142e7d3-01e5-80a1-a1ef-cf42a06f8026" class="bulleted-list"><li style="list-style-type:disc">Pair elements can be accessed by their names (e.g., <code>_1</code>, <code>_2</code>) rather than by index.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-80e4-8ac1-dede120f138e" class="numbered-list" start="3"><li><strong>Pattern Matching</strong>:<ul id="1142e7d3-01e5-80cd-9913-f2f6750f9f5e" class="bulleted-list"><li style="list-style-type:disc">Utilize pattern matching with case lambdas for cleaner code.</li></ul><ul id="1142e7d3-01e5-8064-a25c-ed17d6f7519b" class="bulleted-list"><li style="list-style-type:disc">Anonymous functions can unpack pairs directly using pattern matching.</li></ul><ul id="1142e7d3-01e5-8004-ac68-c819499e0e09" class="bulleted-list"><li style="list-style-type:disc">The structure of pattern matching allows binding names to specific parts of data structures.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-806a-b20f-e1f63f49e611" class="numbered-list" start="4"><li><strong>Handling Optional Values</strong>:<ul id="1142e7d3-01e5-8035-b624-dce53302fff0" class="bulleted-list"><li style="list-style-type:disc">Use <code>Option</code> to handle possible absence of values, distinguishing between <code>None</code> and <code>Some(value)</code>.</li></ul><ul id="1142e7d3-01e5-8057-98ec-fa199e4e3db4" class="bulleted-list"><li style="list-style-type:disc">Pattern matching can identify whether an optional value is present or absent.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-806b-be06-f1d48ff7522a" class="numbered-list" start="5"><li><strong>Match Expression</strong>:<ul id="1142e7d3-01e5-8050-a020-f7a725166373" class="bulleted-list"><li style="list-style-type:disc">The <code>match</code> expression in Scala allows for structured control flow based on value patterns.</li></ul><ul id="1142e7d3-01e5-8018-a646-f14f2aca45d9" class="bulleted-list"><li style="list-style-type:disc">Can match against types and destructure collections into named variables.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-8082-baef-ffd75ac60815" class="numbered-list" start="6"><li><strong>Recursive Patterns</strong>:<ul id="1142e7d3-01e5-80a4-8fba-eae46b34d09e" class="bulleted-list"><li style="list-style-type:disc">Recursive calls can be simplified using named variables in pattern matching.</li></ul><ul id="1142e7d3-01e5-804a-aa6a-e236f36a48ee" class="bulleted-list"><li style="list-style-type:disc">Enhances readability and efficiency in function definitions.</li></ul></li></ol><h3 id="1142e7d3-01e5-8045-a6b1-ca190af8d92b" class="">Additional Considerations</h3><ul id="1142e7d3-01e5-800d-bf7c-edf266a97252" class="bulleted-list"><li style="list-style-type:disc">When working with maps and collections, prefer functional style for cleaner code.</li></ul><ul id="1142e7d3-01e5-80e8-874c-fd92ab364517" class="bulleted-list"><li style="list-style-type:disc">Leverage the power of pattern matching to make your code more expressive and maintainable.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.5em;line-height:1.3;margin:0">Other Notes</summary><div class="indented"><ol type="1" id="1142e7d3-01e5-80b0-ac6e-cd7084bff9aa" class="numbered-list" start="1"><li><strong>Shadowing Variables:</strong><ul id="1142e7d3-01e5-800b-a84d-ec8953917126" class="bulleted-list"><li style="list-style-type:disc">Shadowing occurs when a variable declaration in a scope has the same name as a variable in an outer scope.</li></ul><ul id="1142e7d3-01e5-80b1-8d05-f338f3b8ad7e" class="bulleted-list"><li style="list-style-type:disc">This is considered poor coding style and can lead to confusion. In the context of the example given, it was noted that the expression was only valid in this case, but generally, this practice should be avoided.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-8064-8978-f177bdee380b" class="numbered-list" start="2"><li><strong>Using </strong><code><strong>dot</strong></code><strong> for Scala Imports:</strong><ul id="1142e7d3-01e5-8018-b38e-f941efa8d095" class="bulleted-list"><li style="list-style-type:disc">When importing packages in Scala, decorators can enhance existing Java classes, allowing seamless integration.</li></ul><ul id="1142e7d3-01e5-800f-a857-e4f5a7dd1eae" class="bulleted-list"><li style="list-style-type:disc">Example: The <code>JavaConverters</code> package decorates Java collections, enabling Scala features to be utilized on them.</li></ul></li></ol><ol type="1" id="1142e7d3-01e5-8024-9c4f-da9e5d55158c" class="numbered-list" start="3"><li><strong>Wrapper Behavior:</strong><ul id="1142e7d3-01e5-8007-94d3-f23747c5cbe1" class="bulleted-list"><li style="list-style-type:disc">Converting Java collections into Scala collections via decorators creates a wrapper, not a deep copy.</li></ul><ul id="1142e7d3-01e5-8079-abc3-e14c2839de5c" class="bulleted-list"><li style="list-style-type:disc">This means accessing elements via index uses the original Java collection without duplicating its contents.</li></ul></li></ol><h3 id="1142e7d3-01e5-805b-982a-c7b43fc1d253" class="">Additional Insights</h3><ul id="1142e7d3-01e5-8026-8df9-fb43ad32d087" class="bulleted-list"><li style="list-style-type:disc">The lecturer acknowledged the challenges in adapting to different IDEs and the variability of support for Scala features across them.</li></ul><ul id="1142e7d3-01e5-80c8-850c-fffc23c28a6f" class="bulleted-list"><li style="list-style-type:disc">A light-hearted note about personal programming history illustrates how diverse programming environments can shape learning experiences.</li></ul><ul id="1142e7d3-01e5-8073-9b4a-c2d14ffb56c5" class="bulleted-list"><li style="list-style-type:disc">Encouraged students to develop their coding skills without being overly reliant on IDE features, reinforcing the importance of understanding the underlying concepts.</li></ul><h3 id="1142e7d3-01e5-80bd-926d-ceb0ba13ceb1" class="">Summary</h3><p id="1142e7d3-01e5-80ab-8f8d-dda42a510d27" class="">The lecture focused on practical Scala programming, the use of appropriate IDEs for development, and the significance of coding practices like avoiding variable shadowing and code duplication. It emphasized a balance between utilizing powerful tools like IntelliJ IDEA and maintaining a strong understanding of the language itself.</p><p id="1142e7d3-01e5-8021-bfef-fe734bf8c771" class="">
</p><p id="1142e7d3-01e5-8036-853f-e98bbc4571fe" class="">
</p><p id="1142e7d3-01e5-80b6-8584-dcf9e333c4b5" class="">
</p><p id="1142e7d3-01e5-80b5-bb90-e2ec2e4400c1" class="">
</p><p id="1142e7d3-01e5-80ac-ac9f-fdf0629251b2" class="">
</p><p id="1142e7d3-01e5-804d-8d88-e1895e329eb4" class="">
</p><p id="1142e7d3-01e5-800f-a07f-cc3f9f365b39" class="">
</p><p id="1142e7d3-01e5-803d-913b-c759597712e1" class="">
</p><p id="1142e7d3-01e5-80d4-9588-f820fd5b7770" class="">
</p><p id="1142e7d3-01e5-80cb-b843-ec047a39bb7d" class="">
</p></div></details></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>